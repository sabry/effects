\documentclass{llncs}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\title{Effects}
\titlerunning{Effects}
\author{Oleg Kiselyov \and Amr Sabry}
\authorrunning{Kiselyov and Sabry}
\institute{? \\
\email{...@...}
\and
...}
\maketitle

%% Submission deadline Oct. 2 
%% 15 pages LNCS style 

\begin{abstract}

\keywords{}
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}

In most programming languages, the type
$\textsf{int} \rightarrow \textsf{int}$ does \emph{not} denote
functions that map integers to integers. Rather, the type would
typically denote functions that accept integers and then \emph{may},
after performing any of a variety of computational actions, return an
integer. Possible intermediate actions performed by the function
evaluation may include:
\begin{itemize}
\item reading and updating external memory locations, environment
  parameters, local or remote file systems or databases, etc;
\item communicating with a user or another local or remote process;
\item suspending the computation for a certain period of time or until
  a certain outside condition happens;
\item resuming other suspended computations;
\item loading, compiling, and executing some other computation;
\item using reflection to examine and perhaps modify the function's
  machine representation;
\item producing multiple answers by arranging for one $\textsf{int}$
  to be returned now and subsequent answers to be returned when the
  method is called again (with the same parameters);
\item checkpointing the entire state to a log, which can be examined
  and resumed later;
\item failing due to any of a number of errors and runtime exceptions;
\item consuming half of the battery life of Phil Wadler's laptop and
  generating enough heat to keep him warm on a cold winter night in
  Scotland.
\end{itemize}
Although Phil did not put it this way, we suspect he may agree that
programming in such languages would be akin to taking, at the same
time, several drugs whose side effects are not even declared on their
labels. If taking one unlabeled drug is dangerous then taking multiple
unlabeled drugs with no possible way of understanding the possible
interactions among their side effects is even more dangerous.

The fundamental question we ask then is how to understand, manage, and
control the possible interactions among side effects of computations.
Ideally the various side effects of individual computations could be
described without reference to other computations and their effects
and such computations could be composed in a modular and extensible
way. The bulk of the paper will review two approaches based on
extensible interpreters~\cite{cartwright-extensible} and monad
transformers~\cite{liang-interpreter} and their relationship.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensible Interpreters}

In 1994, Cartwright and Felleisen~\cite{cartwright-extensible}
introduced a new format for denotational language specifications
called \emph{extended direct semantics}. This style of semantic
specification supports the construction of interpreters for complete
languages by composing interpreters for language fragments each
responsible for a particular effect. In their original proposal, a
complete program is associated with a \emph{central authority} that
administers global resources affected by the program, e.g., the store
or the input and output streams. The evaluation of each program
fragment either returns a value locally or propagates an effect to the
central authority. The central authority performs the action specified
by the effect and (typically) resumes the evaluation of the program
fragment. Thus, a fixed pervasive ability to communicate
back-and-forth with a central authority allows each program fragment
to have a uniform semantic interface irrespective of ambient effects
as the handling of effects performed by individual program fragments
\emph{and their interactions} are all relegated to the central
authority.

To realize this idea, Cartwright and Felleisen introduce
\emph{language transformers} which map an interpreter for a base
language to an interpreter for a larger language. The new interpreter
introduces clauses for the new constructs and introduces a local
administrator to handle the new effects: all other expressions and
effects are relegated to either the base interpreter or to the central
authority.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Monad Transformers}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Extensible Effects}

Monad transformers are tagless-final dual of the Freer Monad, which is
an initial encoding

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Discussion}

Connections to other papers by Phil:  
\begin{itemize}
  \item Combining monads
  \item Monads and composable continuations
  \item Idioms are oblivious, arrows are meticulous, monads are promiscuous
  \item Monadic constraint programming
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{acm}
\bibliography{exteff}
\end{document}



